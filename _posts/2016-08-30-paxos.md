## Paxos
*  the **goal** is to ensure that some proposed value is eventually chosen and, if a value has been chosen, then a process can eventually learn the value.
*  three roles in paxos: proposer, acceptor and learner

* The easiest way to choose a value is to have a single acceptor agent. A proposer sends a proposal to the acceptor, who chooses the first proposed value that it receives. Although simple, this solution is unsatisfactory because the failure of the acceptor makes any further progress impossible. So, let’s try another way of choosing a value. Instead of a single acceptor, let’s use multiple acceptors. A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is large enough? To ensure that only a single value is chosen, we can let a large enough set consist of any majority of the nodes.
* **proposal's algorithm**:
	* A proposer chooses a new proposal number n and sends a request(I will call such a request a prepare request with number n) to each member of some set of acceptors, asking it to respond with:		* A promise never again to accept a proposal numbered less than n, and		* The proposal with the highest number less than n that it has accepted, if any
	* If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals. A proposer issues a proposal by sending, to some set of acceptors, a request that the proposal be accepted. (This need not be the same set of acceptors that responded to the initial requests.) Let’s call this an accept request.
* **acceptor's algorithm**:
	* acceptor can receive two kinds of requests from proposers: prepare requests and accept requests. An acceptor can ignore any request without compromising safety(must accept first proposal). It can always respond to a prepare request. It can respond to an accept request, accepting the proposal, iff it has not promised not to. In other words: An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n.
* optimization:
	* Suppose an acceptor receives a prepare request numbered n, but it has already responded to a prepare request numbered greater than n, thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request, since it will not accept the proposal numbered n that the proposer wants to issue. So we have the acceptor ignore such a prepare request.
* **put it together**:
	* Phase 1
		* A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.		* If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.	* Phase 2
		* If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.
		* If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.
* To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm is to have each acceptor, whenever it accepts a proposal, respond to all learners, sending them the proposal. This allows learners to find out about a chosen value as soon as possible, but it requires each acceptor to respond to each learner - a number of responses equal to the product of the number of acceptors and the number of learners.
* **It’s easy to construct a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers infinitely, none of which are ever chosen**. Proposer p completes phase 1 for a proposal number n1. Another proposer q then completes phase 1 for a proposal number n2 > n1. Proposer p’s phase 2 accept requests for a proposal numbered n1 are ignored because the acceptors have all promised not to accept any new proposal numbered less than n2. So, proposer p then begins and completes phase 1 for a new proposal number n3 > n2, causing the second phase 2 accept requests of proposer q to be ignored. And so on. **An optimization for this is to select a distinguished proposer as the only one to try issuing proposals.**
* to guarantee **monotonic increasing of proposal number**, for example, if there are K proposors in total, then proposor i chooses its proposal number from the sequence like: i, i + K, i + 2K, i + 3K ...
* **paxos state machine**: use a sequence of paxos consensus algorithms to determine event sequence, each event with an instance of paxos algorithm;