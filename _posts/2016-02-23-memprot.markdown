==> GPDB has a memory protection mechanism, which is a wrapper of
	malloc/calloc/free along with the vmem_tracker, the interface
	is gp_malloc etc.

	gp_malloc would check whether memory protection is enabled, if
	no, bare malloc would be invoked; if yes, then it would first
	reserve quota from vmem_tracker, if request to vmem_tracker fails,
	for per-query memory limit hit or segment memory quota hit, then
	gp_failed_to_alloc would be called to report the OOM catagory and use
	MemoryAccounting_SaveToLog() to write the memory accounting tree to log
	with write_stderr, and MemoryContextStats() to write the useage details
	of a TopMemoryContext to log; then gp_failed_to_alloc would check whether
	core dump is requested, and raise a ERROR to abort current query;

	There are cases the memory accouting tree is very huge, e.g, consuming
	more than 100,000 lines of log to record in JIRA 26198; during the logging
	process, there are chances of calling bare malloc by other backends, thus
	leading to NULL return and possible SIGSEGV(JIRA MPP-26198), and hence
	postmaster reset, so no ERROR could be observed;

	vmem_tracker is just a memory counter;

	If vmem_tracker says yes for the request, then gp_malloc_internal would call
	malloc or calloc, if NULL is returned(system OOM), then system OOM catagory
	would be recorded in log by gp_failed_to_alloc;

	AllocSetAllocImpl uses gp_malloc, hence palloc;

	ReportOOMConsumption is called in critical spot of query execution, for
	example ExecutorEnd, and CHECK_FOR_INTERRUPTS, it is to check whether new
	OOM happend on the whole segment, if yes, then report current process'
	memory usage to log;
