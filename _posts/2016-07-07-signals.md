### SIGNALs in GPDB
* The SIGUSR1 signal is multiplexed to support signalling multiple event types. The specific reason is communicated via flags in shared memory. We keep a boolean flag for each possible "reason", so that different reasons can be signaled to a process concurrently. (However, if the same reason is signaled more than once nearly simultaneously, the process may observe it only once.)
* ProcSignalSlot struct is used to record signal flag in share memory, if process A wants to signal SIGUSR1 to process B with reason Catchup, then A finds ProcSignalSlot of B, and set the flag field to true; each process would have a static variable MyProcSignalSlot to refer to the its slot in share memory, and the wrapper to check the flag is CheckProcSignal. The function to send a sigusr1 to another process is SendProcSignal.
* Now, SIGUSR1 is used for Catchup event, QueryFinish event, and Notify event, Notify event is disabled in GPDB.
* handler of SIGUSR1 is registered to be procsignal_sigusr1_handler, procsignal_sigusr1_handler would triage the signal reason and call corresponding handlers; for Catchup event, the handler is HandleCatchupInterrupt, this function would check catchupInterruptEnabled before taking substantial actions.
* Handler function of SIGUSR1 is procsignal_sigusr1_handler, and this function would triage the reason of the signal and branch into HandleCatchupInterrupt or QueryFinishHandler; QueryFinishHandler would only set a flag and exit, while HandleCatchupInterrupt would check whether catchupInterruptEnabled is true to decide doing the heavy work or not.
* Handler function of SIGUSR2 is NotifyInterruptHandler, which is quite like HandleCatchupInterrupt.
* Handler function of SIGALRM is handle_sig_alarm, which is quite like procsignal_sigusr1_handler. There are three branches for SIGALRM, i.e, CHeckStatementTimeout, HandleClientWaitTimeout and CheckDeadLock.
* Rules of thumb to avoid signal issues are:
	* prohibit non-reentrable function calls in handler;
	* avoid doing weight lifting in handler function, instead, we should only set simple flags and exit, and leave the heavy work to other same places;
	* avoid reentrant signal handling;
* In GPDB, handling of SIGUSR1, SIGUSR2, SIGINT and SIGTERM follows the rules mentioned above, while for SIGALRM, it is not good, especially CheckStatementTimeout, this function is possibly to be called almost everywhere(sadly, that is the intention of SIGALRM), and it does not prevent reentrant signal handling of other signals. Therefore, it is possible to get self-deadlock in CheckStatementTimeout.