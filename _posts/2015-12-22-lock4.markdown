==> waitedLock is used for keep LOCALLOCK valid in error cases, it is first set
	in the begining of WaitOnLock, and set back in the end of WaitOnLock; it is
	used by WaitLockCancel to GrantLocalLock if found share lock granted, and
	process itself is not able to GrantLocalLock before interruption;

	It is possible that LOCALLOCK entry exists for a lock and lockmode, while the
	lock and proclock field is null, that is caused by "out of share memory"
	when allocating lock and proclock, and thus ERROR would go into
	LockWaitCancel, it would not call RemoveLocalLock, let alone the awaitedLock
	is not set yet;

	LockWaitCancel is called when transaction is committed or aborted, or in
	die/StatementCancelHandler, or in ResourceOwnerReleaseInternal;

==> LockReleaseAll would first modify LOCALLOCK entries, then modify LOCK and
	PROCLOCK partition by partition, this can reduce the LWLockAcquire cost;

==> AtPrepare\_Locks would traverse the LOCALLOCK, and record the locks held
	into a XLogRecData list which resides in memory context; this function is
	called in PrepareTransaction;

	After successful PREPARE, the ownerships of current held locks would be
	transferred to a dummy PGPROC, which is associated with the prepared
	transaction; hence all the corresponding entries in LOCALLOCK would be
	removed; this is done by function PostPrepare_Locks, which is called in
	function PrepareTransaction;

	Note that, for a dummy PGPROC of a prepared transaction, there is no
	LOCALLOCK, it is in another form as TwoPhaseLockRecord;

	PostPrepare_Locks is quite similar as LockReleaseAll: first go through
	LOCALLOCK and mark releaseMask of proclock, then clean up LOCK and PROCLOCK;

==> All the temporary objects are put under a temp namespace;

==> hash\_seq\_search a HTAB(dynahash.c) can handle the case when HTAB is
	inserted during the traversal, however, whether the newly appended entries would
	be traversed or not should be double checked;

==> GetLockStatusData is used by user level function such as pg\_locks, one
	thing is that we should grab all the partition lock first before we copy any
	data, this is to guarantee we have a self-consistent view of the state;

==> lock\_twophase\_recover is registered as a callback, which would be called
	in RecoverPreparedTransactions; it is quite similar as LockAcquire, except
	that it does not check the conflicts, and grant the lock any how;

	Differences:
	--> locallock does not included in this function;
	--> the proc in PROCLOCK is the dummy proc for prepared transaction;
	--> no conflicts check; XXX any problems? in what situation this function is called?

	Similarly, lock_twophase_postcommit would be called in
	FinishPreparedTransaction; it is quite like LockRelease, differences:
	--> no locallock involved;
	--> dummy proc in PROCLOCK;

	lock_twophase_postabort is just exactly same as lock_twophase_postcommit, so
	if a COMMIT PREPARE fails, then the locks of the dummy PGPROC would be
	released, so lock_twophase_recover should re-acquire them later;

	XXX Are TwoPhaseLockRecords flushed to disk?
