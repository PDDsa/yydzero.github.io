### Cache Invalidation of PG
============================
* For catalog tables, the visibility check is using SnapshotNow, so for each command, if the command itself modifies the catalog table, the change should not reflected in cache until the next command.
* If someone modifies the catalog table, it should broadcast this event to other backends through SI message queue **after commiting transaction**, so other backends can see these modifications from catalog table and update their caches.
* Q: if we are INSERT/DELETE catalog tables, should we register this modification so that the at the beginning of the next command we can update our cache? or at the end of the transaction we can broadcast this event. A: the registeration is done in `CacheInvalidateHeapTuple`, which would be called by `heap_insert`, `heap_delete`, `heap_update`, `heap_inplace_update` and `heap_prune_chain`, that is to say, if we manipulate catalog tables through heap interfaces, we do not bother to do the registeration.
* Q: when does the update of our own cache happen if we ourself modify catalog table? A: in `CommandCounterIncrement` after query execution, it would call `AtCommit_LocalCache` -> `CommandEndInvalidationMessages` to reflect the change of this command to local cache.
* Q: If we are using syscache for reading catalog tables, for a single command, if there are several readings, are these readings consistent? A: NO, if other transactions modifies catalog table, and broadcast the event, ideally, each time we want to use the cache, we need to check whether there exists invalidation, so the good practice of using syscache is to call `AcceptInvalidationMessages` first and then use the syscache. This is encapsulated by `heap_open`, each time `heap_open` with a lock mode, it would call one of `LockRelation`, `LockRelationOid`, `ConditionalLockRelation`, `ConditionalLockRelationOid`, which would call `AcceptInvalidationMessages`, so the good practice of using syscache is to `heap_open` the table with a lock. However, there still exists race condition, i.e, invalidation comes after we lock the relation (AccessShareLock does not conflict RowExclusiveLock), but before we use the syscache, then it would be possible to read an deleted tuple from syscache.
* Given the race condition of syscache, we'd better using `systable_beginscan` to bypass the cache level.
* **WARNING**: when using `systable_beginscan`, access the HeapTuple returned before `systable_endscan`, otherwise, the memory referenced by HeapTuple would be pfreed.