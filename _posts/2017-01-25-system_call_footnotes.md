## System call footnotes
========================
* `poll`: The field revents is an output parameter, filled by the kernel with  the events that actually occurred. The bits returned in revents can include any of those specified in events, or one of the values `POLLERR`, `POLLHUP`, or `POLLNVAL`. On success, a positive number is returned; this is the number of structures which have **nonzero revents fields** (in other words,  those  descriptors with events or errors reported). For example, if you specify `POLLOUT` in the events field, and `poll` would return a positive number if `POLLERR` happens on that fd;
* signal and interrupt: interrupt is a hardware mechanism, CPU would check the pin for interrupt after each instruction, and execute the instructions stored in IDT; signal just silumates this mechanism, but it would not touch the pin, but store the flag in task struct, each time CPU returns from kernel space to user space, it would check the flag, and execute the instructions stored in task struct(signal handler); the interesting point here is the stack recovery method, before calling signal handler, OS would store the registers of the task into the stack of the task, and then change the IP to signal handler, at the end of signal handler, **there is a system call `sys_signalreturn` to trap into kernel**, and OS can take over and restore the registers and stack of the process;
* How system call trap into kernel space? system call would be compiled to asm code "INT 0x80"(128), when CPU executes instructions of INT, it would act as if there is hign volt in pin, this is the real software interrupt; this is the only chance to trap into kernel from user space; dtrace use `INT 3` to replace the origin `nop` asm instruction in the binary, and put the fire code into the 3rd entry of IDT(INT 3 is 'breakpoint'); so signal uses software interrupt, because it uses system call to trap into kernel, but the main mechanism is a software behavior implemented by OS.