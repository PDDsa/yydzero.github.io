==> LOCALLOCK is mainly for recording the number of times the lock has been
	acquired, since a process/transaction would be counted only once in share
	memory lock; the numbers are tracked per ResourceOwner;
	Main fields:
	--> LOCALLOCKTAG tag: combination of LOCKTAG and lockmode;
	--> LOCK *lock: corresponding lock in share memory; LOCALLOCK in process
		private, so we can use pointer directly;
	--> PROCLOCK *proclock: corresponding proclock in share memory;
	--> int64 nLocks; number of times acquired;

==> LOCK, PROCLOCK, and LOCALLOCK are organized into hash table
	LockMethodLockHash, LockMethodProcLockHash and LockMethodLocalHash in share
	memory;

==> Function InitLocks is called in postmaster startup, it creates those 3 hash
	tables; there is an assumption of average 2 holders per lock(estimated number of
	PROCLOCK);

==> A question of LockAcquire is: the order of insert/modify LOCALLOCK/PROCLOCK
	and LOCK; should them be atomic?
	Answer: yes, they are atomic, protected by LWLockAcquire(partitionLockId);
	First, allocate entry in LOCALLOCK, LOCK and PROCLOCK, not modify the entry,
	then after check conflicts, call GrantLock to modify LOCK and PROCLOCK, and
	GrantLocalLock to modify LOCALLOCK;
	--> the concurrency is protected by LWLockAcquire(partionLockId);
	--> there is no ereport in GrantLock and GrantLocalLock, so cannot longjump
		to escape the atomic protection;
	--> there is no CHECK_FOR_INTERRUPTS in function LockAcquire, so no
		interrupts;

==> LockMethodLockHash is logically divided into several partitions using hash,
	so when reading/writing a LOCK entry, use corresponding partition's LWLockId
	for concurrency protection;

==> global variable lockHolderProcPtr is a pointer to a PGPROC which is
	responsible for locking stuff, i.e, for utility mode and QD, it's itself, for
	QE on segments, it's the writer's PGPROC; However, reader can indeed
	possibly acquire locks, when writer is not found after 5 attempts(lock.c:595);
	XXX if reader gang acquired locks, is there any risk we do not release them?

==> hash\_search would first calculate the hash value of the key,
	hash_search_with_hash_value would directly use the hash_value param and then
	check the match of the key;
	
	LOCALLOCK->hashcode is the hash value of the LOCKTAG in LOCALLOCKTAG, not
	LOCALLOCKTAG itself; 
	
	There is a function pointer in struct HTAB, which specifies the memory allocator
	to be used in hash table, when action is HASH_ENTER_NULL, the pointer cannot be palloc
	related function;

==> XXX why use MyProc instead of lockHolderProcPtr in PROCLOCKTAG?(lock.c:682)
	
	When no finding in LOCALLOCK, while PROCLOCK shows the LOCK has been
	acquired, why we still go on acquiring the lock?!! something is corrupted,
	either LOCALLOCK or PROCLOCK, why we do not report error?(lock.c:805)
	check the master log from GE for this kind of LOG(lock.c:811)
	The assumption there is the share memory is OK, while the LOCALLOCK is
	corrupted;

==> GrantLock is to modify the LOCK and PROCLOCK structures' fields(number and
	lockmask) to reflect that the lock has been granted to the process;

==> LockCheckConflicts would count the lock modes already held by this process,
	and the processes has same mppSessionId, so it's OK for reader QE to acquire
	locks, XXX but the numbers may have problem here, though the PROCMASK and
	conflict relationship is OK;

==>	why in ProcSleep we should check LockCheckConflicts again? the
	partitionLockId is always held by us(proc.c:974).

	Answer: in LockAcquire, we can get STATUS_FOUND when finding the target
	mode, e.g, mode x, is in waitMask, then dive into ProcSleep without really
	checking LockCheckConflicts, however, if another process is waiting for the
	lock for mode x, and we are inserted before it in wait list, then we cannot
	say we are really blocked by the lock without calling LockCheckConflicts;

	
==> Acquisition of either a spinlock or a lightweight lock would let cancel and
	die interrupts to be held off until all such locks are released by
	HOLD_INTERRUPTS/RESURE_INTERRUPTS. No such restriction exists for regular locks;
	We can accept cancel and die interrupts while waiting for a regular
	lock(verified manually); it is implemented in function PGSemaphoreLock(true),
	for LWLock and spinlock, the param is false; see the comments in
	posix_sema.c:246, very helpful

==> The partition's LWLock is considered to protect all the LOCK objects of that
	partition as well as *their subsidiary PROCLOCKs*; The other lock related
	fields of a PGPROC are only interesting when the PGPROC is waiting for a
	lock, so we consider that they are protected by the partition LWLock of the
	awaited lock;

==> Deadlock of regular lock can be caused by:
	--> between different modes of a single lock; this is detected when trying
		to insert the PGPROC into the wait list of the lock by function
		ProcSleep(); deadlock check can handle this case as well, but direct
		adjustment in ProcSleep is cheaper without incurring a deadlock timeout;
	--> between different locks: this kind of deadlock checking would LWLock all
		the partitions in partition-number order(to avoid LWLock deadlock); see
		README

		The deadlock checking is triggered by timer DeadLockTimeout, ususally
		one second, the deadlock is resolved usually be aborting the detecting
		process' transaction, or re-arrange the wait list of a lock if possible;
		Deadlock detection is an independent component, and is elaborated quite
		clear in README.

==> ProcLockWakeup is called when a lock is released by UnGrantLock or
	*a prior waiter is aborted*; Must call ProcLockWakeup after releasing a lock
	or re-arrange the wait list of a lock, to guarantee no missing wakable
	process;

	"When a lock is released, the lock release routine (ProcLockWakeup) scans
	the lock object's wait queue.  Each waiter is awoken if (a) its request
	does not conflict with already-granted locks, and (b) its request does
	not conflict with the requests of prior un-wakable waiters.  Rule (b)
	ensures that conflicting requests are granted in order of arrival. There
	are cases where a later waiter must be allowed to go in front of
	conflicting earlier waiters to avoid deadlock, but it is not
	ProcLockWakeup's responsibility to recognize these cases; instead, the
	deadlock detection code will re-order the wait queue when necessary."
																	--README

	When waking up a process, first update the share memory state before going
	to call the PGSemaphoreUnlock, to gurantee the lock grant is recorded in
	case the waked process is interrupted just after the wakeup; see
	posix_sema.c:272

==> Only LockAcquire would call WaitOnLock, only WaitOnLock would call ProcSleep;

==> TODO:
	In ProcSleep, if we find a deadlock when trying to insert the PGPROC into
	the wait list, i.e, when early_deadlock is true, we do not have to call
	ProcLockWakeup in RemoveFromWaitQueue->CleanUplock, because the begin state
	is exactly same as the end state per the wait list, and the temporary
	different state cannot be seen by anyone since the partition lwlock is held
	by us all the time;

==> In the case when lock is not available, partition LWLock is released only when
	we have finished inserting the PGPROC into the wait list in ProcSleep; 

==> LockWaitCancel would be called in cancel/die handler;
	XXX there is a comment in LockWaitCancel, saying "Don't try to cancel
	resource locks";
	XXX is there problems resource lock uses same awaitedLock as regurlar locks?

	LockWaitCancel is responsible for keep LOCALLOCK valid in race condition
	when we are granted the lock and not able to record it in LOCALLOCK because
	of cancel/die interrupts; see proc.c:1069 and posix_sema.c:272

==> Both ProcSleep and ProcWaitForSignal(signal means "clue" here) are
	implemented using PGSemaphore, but a process cannot call this two function
	at the same time, so it's OK; the only thing concerns is a special case when
	a process first call ProcWaitForSignal, then was aborted, and then another
	process calls ProcSendSignal, then the first process call ProcSleep, there
	would be a leftover "signal" there, so we should use:
	do
	{
		PGSemaphoreLock();
	} while(MyProc->waitStatus == STATUS_WAITING)
	to check we indeedly get the lock;
	
	After exiting the do while loop, the MyProc->waitStatus can be STATUS_OK or
	STATUS_ERROR when deadlock detected and RemoveFromWaitQueue called in
	handle_sig_alarm->CheckDeadLock

==> XXX in ProcSleep, there is no need to re-acquire the partition LWLock again,
	since the interrupts is delayed to CHECK_FOR_INTERRUPTS;

==> Auxiliary processes are not expected to acquire regular locks, but they
	would do for LWLock, thus PGPROC is necessary;
